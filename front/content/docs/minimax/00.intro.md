---
group: "Minimax"
icon: "pi-bolt"
---

# Introduction: Motivation and Board Representation

## What is Minimax Search

Minimax is the classical algorithm for two-player zero-sum games. The idea is simple: one player maximizes the score, the other minimizes it, and both play optimally. At every game state, the algorithm considers all possible moves, alternating between max and min layers to compute the minimax value:

$$v(s) = \max_{a \in A(s)} \min_{b \in B(s)} v(s')$$

Gomoku is a natural fit for minimax: it's a game of perfect information, zero-sum, and deterministic. But the 19x19 board creates a branching factor of roughly 200+ legal moves per position — making naive minimax computationally intractable at any meaningful depth. Everything in this engine is about taming that branching factor.

## Why C++

The initial implementation was written in Python. It worked for small boards, but the performance gap became unacceptable on a 19x19 board — particularly for double-three detection, which requires recursive rule checking on every candidate move during search. C++98 was chosen because of familiarity from previous [École 42](https://42.fr) projects, combining comfort with the raw performance needed for the hot paths.

The key architectural decision was to represent the board as **bitboards**: two arrays of `uint64_t[19]`, one per player. This makes move generation, pattern matching, and evaluation a matter of bitwise operations instead of array iteration. Even after the bitmask-based double-three detection was later found to produce incorrect results in certain edge cases and was removed (see [Game Rules](/docs/rules-and-serving)), the bitboard representation was kept because it remains the performance foundation for the evaluation function — the real hot path in the search.

<!-- DIAGRAM: Architecture overview: WebSocket Request → JSON Parser → Board (bitboard) → Search Engine → Evaluation (Pattern Lookup Table) → Response. Show the data flow linearly. -->

## Bitboard Design

The board is stored as two separate `uint64_t` arrays — one for each player:

```cpp
// minimax/inc/gomoku/Board.hpp:53-54
uint64_t last_player_board[BOARD_SIZE];
uint64_t next_player_board[BOARD_SIZE];
```

Each `uint64_t` represents one row of the 19x19 board. Bits 0–18 correspond to columns; bits 19–63 are unused. Keeping separate bitboards per player (rather than a single tri-state board) enables fast OR for occupancy checks and fast AND/SHIFT for pattern extraction in the evaluation function.

**Move generation** uses neighbor masks to restrict candidates to positions adjacent to existing stones. Rather than iterating all 361 positions, the engine computes a bitmask of cells neighboring occupied positions using horizontal, vertical, and diagonal bit shifts:

```cpp
// minimax/src/gomoku/search/Minimax.cpp:25-43
void computeNeighborMask(const uint64_t occupancy[BOARD_SIZE],
                         uint64_t neighbor[BOARD_SIZE]) {
  for (int i = 0; i < BOARD_SIZE; i++) {
    uint64_t row = occupancy[i];
    uint64_t horz = shiftRowLeft(row) | shiftRowRight(row) | row;
    uint64_t vert = 0;
    if (i > 0) vert |= occupancy[i - 1];
    if (i < BOARD_SIZE - 1) vert |= occupancy[i + 1];
    uint64_t diag = 0;
    if (i > 0) {
      diag |= shiftRowLeft(occupancy[i - 1]);
      diag |= shiftRowRight(occupancy[i - 1]);
    }
    if (i < BOARD_SIZE - 1) {
      diag |= shiftRowLeft(occupancy[i + 1]);
      diag |= shiftRowRight(occupancy[i + 1]);
    }
    neighbor[i] = horz | vert | diag;
  }
}
```

ANDing the neighbor mask with NOT-occupancy yields only the empty cells near existing stones — typically reducing candidates from 361 to around 20–40 per position. This is where bitboards pay off most: what would be a nested loop over every cell becomes a handful of bitwise operations per row.

**Zobrist hashing** provides incremental board hashing for the transposition table. A table of random 64-bit keys (`piece_keys[19][19][3]`) is generated at startup using Boost's MT19937 RNG. Placing or removing a stone XORs the corresponding key into the hash — no full-board recomputation ever needed.

**Undo/Redo** during search uses an `UndoInfo` struct that records the move and any captured stones. The board is mutated in-place and restored after each recursive call, avoiding expensive board copies at every search node.

<!-- DIAGRAM: Row-to-uint64 bit mapping. Show a 19-cell row and how each cell maps to a bit position in a uint64_t. Mark bits 0-18 used, bits 19-63 unused. -->

## Difficulty Modes

The engine exposes three difficulty levels, each selecting a different search algorithm and evaluation function:

| Difficulty | Search Algorithm | Max Depth | Time Limit | Eval Function |
|------------|-----------------|-----------|------------|---------------|
| Easy | Alpha-Beta | 5 | None | Simple |
| Medium | Iterative Deepening | 10 | 0.4s | Simple |
| Hard | PVS | 10 | None | Hard (pattern-counted) |

```cpp
// minimax/src/ws/request_handlers.cpp:14-29
std::pair<int, int> selectBestMove(Board* board, int last_x, int last_y,
                                   const std::string& difficulty) {
  if (last_x == -1 && last_y == -1)
    return std::make_pair(BOARD_SIZE / 2, BOARD_SIZE / 2);

  if (difficulty == "hard")
    return Minimax::getBestMovePVS(board, MAX_DEPTH,
                                   &Evaluation::evaluatePositionHard);
  if (difficulty == "medium")
    return Minimax::iterativeDeepening(board, MAX_DEPTH, 0.4,
                                       &Evaluation::evaluatePosition);
  if (difficulty == "easy")
    return Minimax::getBestMove(board, 5, &Evaluation::evaluatePosition);

  return std::make_pair(-1, -1);
}
```

The simple evaluation function uses raw lookup table scores (fast, sufficient for lower difficulties). The hard evaluation counts specific pattern types and applies nuanced capture vulnerability analysis — details in [Evaluation](/docs/evaluation).

## References

- [Alpha-beta pruning explanation (Korean)](https://going-to-end.tistory.com/entry/%EC%95%8C%ED%8C%8C-%EB%B2%A0%ED%83%80-%EA%B0%80%EC%A7%80%EC%B9%98%EA%B8%B0-Alpha-beta-pruning)
- [Minimax / Alpha-Beta overview (YouTube)](https://www.youtube.com/watch?v=AM-4drnj63w)
